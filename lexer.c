#include <stdio.h>
#include <ctype.h>
#include <string.h>

#include "lexer.h"

#include <iso646.h>
#include <stdlib.h>

#include "utils.h"

Token tokens[MAX_TOKENS];
int nTokens;

int line=1;		// the current line in the input file

// adds a token to the end of the tokens list and returns it
// sets its code and line
Token *addTk(int code){
	if(nTokens==MAX_TOKENS)err("too many tokens");
	Token *tk=&tokens[nTokens];
	tk->code=code;
	tk->line=line;
	nTokens++;
	return tk;
	}

// copy in the dst buffer the string between [begin,end)
char *copyn(char *dst,const char *begin,const char *end){
	char *p=dst;
	if(end-begin>MAX_STR)err("string too long");
	while(begin!=end)*p++=*begin++;
	*p='\0';
	return dst;
	}

void tokenize(const char *pch){
	const char *start;
	Token *tk;
	char buf[MAX_STR+1];
	for(;;){
		switch(*pch){
			case ' ':case '\t':pch++;break;
			case '\r':		// handles different kinds of newlines (Windows: \r\n, Linux: \n, MacOS, OS X: \r or \n)
				if(pch[1]=='\n')pch++;
				// fallthrough to \n
			case '\n':
				line++;
				pch++;
				break;
			case '\0':addTk(FINISH);return;
			case ',':addTk(COMMA);pch++;break;
			case ';':addTk(SEMICOLON);pch++;break;
			case '(':addTk(LPAR);pch++;break;
			case ')':addTk(RPAR);pch++;break;
			case ':':addTk(COLON);pch++;break;
			case '+':addTk(ADD);pch++;break;
			case '-':addTk(SUB);pch++;break;
			case '*':addTk(MUL);pch++;break;
			case '/':addTk(DIV);pch++;break;
			case '&': {
				if (pch[1]=='&') {
					addTk(AND);
					pch+=2;
				}
				else {err("lipseste un &",line);}
			}
			case '|': {
				if (pch[1]=='|') {
					addTk(OR);
					pch+=2;
				}
				else {err("lipseste un &",line);}
			}
			case '=':
				if(pch[1]=='='){
					addTk(EQUAL);
					pch+=2;
					}else{
					addTk(ASSIGN);
					pch++;
					}
				break;

			case '!':
				if(pch[1]=='='){
					addTk(NOTEQ);
					pch+=2;
				}else{
					addTk(NOT);
					pch++;
				}
				break;
			case '<':addTk(LESS);pch++;break;
			case '>':
				if(pch[1]=='='){
					addTk(GREATEREQ);
					pch+=2;
				}else{
					addTk(GREATER);
					pch++;
				}
				break;

			case '"':
				for(start=++pch; *pch!='"' && *pch!='\0'; pch++);
				if(*pch!='"') err("string nedeterminat", line);
				char *text = copyn(buf, start, pch);
				tk = addTk(STR);
				strcpy(tk->text, text);
				pch++;
				break;

			default:
				if(isalpha(*pch)||*pch=='_'){
					for(start=pch++;isalnum(*pch)||*pch=='_';pch++){}
					char *text=copyn(buf,start,pch);
					if(strcmp(text,"int")==0){addTk(TYPE_INT);break;}
					if(strcmp(text,"var")==0){addTk(VAR);break;}
					if(strcmp(text,"function")==0){addTk(FUNCTION);break;}
					if(strcmp(text,"if")==0){addTk(IF);break;}
					if(strcmp(text,"else")==0){addTk(ELSE);break;}
					if(strcmp(text,"while")==0){addTk(WHILE);break;}
					if(strcmp(text,"return")==0){addTk(RETURN);break;}
					if(strcmp(text,"real")==0){addTk(TYPE_REAL);break;}
					if(strcmp(text,"str")==0){addTk(TYPE_STR);break;}
					if(strcmp(text,"end")==0){addTk(END);break;}

						tk=addTk(ID);
						strcpy(tk->text,text);

					}

				if(isdigit(*pch)){
					int flag=0;
					for(start=pch++;isdigit(*pch)||*pch=='.';pch++) {
						if (*pch=='.') {
							flag++;
						}
					}
					if (flag > 1) {
						err("numar real scris gresit",line);
					}
					char *text=copyn(buf,start,pch);
					if (flag==0) {
						tk=addTk(INT);
						tk->i=atoi(text);
					}
					if (flag==1) {
						tk=addTk(REAL);
						tk->r=atof(text);
					}

				}


			}
		}
	}

void showTokens() {
	for (int i = 0; i < nTokens; i++) {
		Token *tk = &tokens[i];
		printf("%d ", tk->line);

		switch(tk->code) {
			case ID:        printf("ID:%s\n", tk->text); break;
			case INT:  printf("INT:%d\n", tk->i); break;
			case REAL: printf("REAL:%f\n", tk->r); break;
			case STR:  printf("STR:%s\n", tk->text); break;
			case FUNCTION:  printf("FUNCTION\n"); break;
			case VAR:       printf("VAR\n"); break;
			case IF:        printf("IF\n"); break;
			case ELSE:      printf("ELSE\n"); break;
			case WHILE:     printf("WHILE\n"); break;
			case TYPE_INT:     printf("TYPE_INT\n"); break;
			case TYPE_REAL:   printf("TYPE_REAL\n"); break;
			case TYPE_STR:    printf("TYPE_STR\n"); break;
			case RETURN:    printf("RETURN\n"); break;
			case END:       printf("END\n"); break;
			case LPAR:      printf("LPAR\n"); break;
			case RPAR:      printf("RPAR\n"); break;
			case COLON:     printf("COLON\n"); break;
			case SEMICOLON: printf("SEMICOLON\n"); break;
			case COMMA:     printf("COMMA\n"); break;
			case ADD:       printf("ADD\n"); break;
			case SUB:       printf("SUB\n"); break;
			case MUL:       printf("MUL\n"); break;
			case DIV:       printf("DIV\n"); break;
			case AND:       printf("AND\n"); break;
			case OR:        printf("OR\n"); break;
			case NOT:       printf("NOT\n"); break;
			case NOTEQ:     printf("NOTEQ\n"); break;
			case LESS:      printf("LESS\n"); break;
			case GREATER:   printf("GREATER\n"); break;
			case GREATEREQ: printf("GREATEREQ\n"); break;
			case ASSIGN:    printf("ASSIGN\n"); break;
			case EQUAL:     printf("EQUAL\n"); break;
			case FINISH:    printf("FINISH\n"); break;
			default:        printf("UNKNOWN\n"); break;
		}
	}
}
